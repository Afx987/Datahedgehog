/** Library asset:datahedgehog_monitor/lib/lib/front_end/test/src/incremental/mock_sdk.dart */
import {is,isNot,equals} from "@dart2ts/dart/_common";
import {defaultConstructor,namedConstructor,namedFactory,defaultFactory,DartClass,Implements,With,op,Op,OperatorMethods,DartClassAnnotation,DartMethodAnnotation,DartPropertyAnnotation,Abstract,AbstractProperty,int,bool,double,Omit} from "@dart2ts/dart/utils";
import * as _common from "@dart2ts/dart/_common";
import * as core from "@dart2ts/dart/core";
import * as async from "@dart2ts/dart/async";
import * as lib3 from "@dart2ts/dart/uri";

export var createSdkFiles : (fileSystem : any) => core.DartMap<string,lib3.Uri> = (fileSystem : any) : core.DartMap<string,lib3.Uri> =>  {
    let dartLibraries : core.DartMap<string,lib3.Uri> = new core.DartMap.literal([
    ]);
    var addSdkLibrary : (name : string,contents : string) => void = (name : string,contents : string) : void =>  {
        let path : string = `${name}/${name}.dart`;
        let uri : lib3.Uri = lib3.Uri.parse(`file:///sdk/lib/${path}`);
        fileSystem.entityForUri(uri).writeAsStringSync(contents);
        dartLibraries.set(name,uri);
    };
    addSdkLibrary('core','library dart.core;\nimport \'dart:_internal\';\nimport \'dart:async\';\n\nclass Object {\n  const Object();\n  bool operator ==(other) => identical(this, other);\n  String toString() => \'a string\';\n  int get hashCode => 0;\n  Type get runtimeType => null;\n  dynamic noSuchMethod(Invocation invocation) => null;\n}\n\nclass Null {}\n\nclass Symbol {\n  const factory Symbol(String name) {\n    return null;\n  }\n}\n\nclass Type {}\n\nabstract class Comparable<T> {\n  int compareTo(T other);\n}\n\nabstract class Pattern {}\n\nabstract class String implements Comparable<String>, Pattern {\n  external factory String.fromCharCodes(Iterable<int> charCodes,\n                                        [int start = 0, int end]);\n  String operator +(String other) => null;\n  bool get isEmpty => false;\n  bool get isNotEmpty => false;\n  int get length => 0;\n  String substring(int len) => null;\n  String toLowerCase();\n  String toUpperCase();\n  List<int> get codeUnits;\n}\n\nabstract class RegExp implements Pattern {\n  external factory RegExp(String source);\n}\n\nclass Function {}\nclass Invocation {}\nclass StackTrace {}\n\nclass bool extends Object {\n  external const factory bool.fromEnvironment(String name,\n                                              {bool defaultValue: false});\n}\n\nabstract class num implements Comparable<num> {\n  bool operator ==(Object other);\n  bool operator <(num other);\n  bool operator <=(num other);\n  bool operator >(num other);\n  bool operator >=(num other);\n  num operator +(num other);\n  num operator -(num other);\n  num operator *(num other);\n  num operator /(num other);\n  int operator ^(int other);\n  int operator |(int other);\n  int operator <<(int other);\n  int operator >>(int other);\n  int operator ~/(num other);\n  num operator %(num other);\n  int operator ~();\n  num operator -();\n  int toInt();\n  double toDouble();\n  num abs();\n  int round();\n}\n\nabstract class int extends num {\n  external const factory int.fromEnvironment(String name, {int defaultValue});\n\n  bool get isNegative;\n  bool get isEven => false;\n\n  int operator &(int other);\n  int operator |(int other);\n  int operator ^(int other);\n  int operator ~();\n  int operator <<(int shiftAmount);\n  int operator >>(int shiftAmount);\n\n  int operator -();\n\n  external static int parse(String source,\n                            { int radix,\n                              int onError(String source) });\n}\n\nabstract class double extends num {\n  static const double NAN = 0.0 / 0.0;\n  static const double INFINITY = 1.0 / 0.0;\n  static const double NEGATIVE_INFINITY = -INFINITY;\n  static const double MIN_POSITIVE = 5e-324;\n  static const double MAX_FINITE = 1.7976931348623157e+308;\n\n  double remainder(num other);\n  double operator +(num other);\n  double operator -(num other);\n  double operator *(num other);\n  double operator %(num other);\n  double operator /(num other);\n  int operator ~/(num other);\n  double operator -();\n  double abs();\n  double get sign;\n  int round();\n  int floor();\n  int ceil();\n  int truncate();\n  double roundToDouble();\n  double floorToDouble();\n  double ceilToDouble();\n  double truncateToDouble();\n  external static double parse(String source,\n                               [double onError(String source)]);\n}\n\nclass Iterator<E> {\n  bool moveNext();\n  E get current;\n}\n\nabstract class Iterable<E> {\n  Iterator<E> get iterator;\n  bool get isEmpty;\n  E get first;\n\n  Iterable<R> map<R>(R f(E e));\n\n  R fold<R>(R initialValue, R combine(R previousValue, E element));\n\n  Iterable<T> expand<T>(Iterable<T> f(E element));\n\n  Iterable<E> where(bool test(E element));\n\n  void forEach(void f(E element));\n\n  List<E> toList();\n}\n\nclass List<E> implements Iterable<E> {\n  List();\n  void add(E value) {}\n  void addAll(Iterable<E> iterable) {}\n  E operator [](int index) => null;\n  void operator []=(int index, E value) {}\n  Iterator<E> get iterator => null;\n  void clear() {}\n\n  bool get isEmpty => false;\n  E get first => null;\n  E get last => null;\n\n  R fold<R>(R initialValue, R combine(R previousValue, E element)) => null;\n}\n\nclass Map<K, V> extends Object {\n  V operator [](K key) => null;\n  void operator []=(K key, V value) {}\n  Iterable<K> get keys => null;\n  int get length;\n  Iterable<V> get values;\n}\n\nclass Duration implements Comparable<Duration> {}\n\nexternal bool identical(Object a, Object b);\n\nvoid print(Object o) {}\n\nabstract class _SyncIterable implements Iterable {}\n');
    addSdkLibrary('async','library dart.async;\n\nclass Future<T> {\n  factory Future(computation()) => null;\n  factory Future.delayed(Duration duration, [T computation()]) => null;\n  factory Future.microtask(FutureOr<T> computation()) => null;\n  factory Future.value([value]) => null;\n\n  static Future<List<T>> wait<T>(Iterable<Future<T>> futures) => null;\n  Future<R> then<R>(FutureOr<R> onValue(T value)) => null;\n\n  Future<T> whenComplete(action());\n}\n\n\nclass FutureOr<T> {}\nclass Stream<T> {}\nabstract class StreamIterator<T> {}\n\nabstract class Completer<T> {\n  factory Completer() => null;\n  factory Completer.sync() => null;\n  Future<T> get future;\n  void complete([FutureOr<T> value]);\n  void completeError(Object error, [StackTrace stackTrace]);\n  bool get isCompleted;\n}\n\nclass _StreamIterator<T> implements StreamIterator<T> {}\nclass _AsyncStarStreamController {}\nFunction _asyncThenWrapperHelper(continuation) {}\nFunction _asyncErrorWrapperHelper(continuation) {}\nFuture _awaitHelper(\n    object, Function thenCallback, Function errorCallback, var awaiter) {}\n');
    addSdkLibrary('collection','library dart.collection;');
    addSdkLibrary('convert','library dart.convert;');
    addSdkLibrary('developer','library dart.developer;');
    addSdkLibrary('io','library dart.io;');
    addSdkLibrary('isolate','library dart.isolate;');
    addSdkLibrary('math','library dart.math;\ndouble sin(num radians) => _sin(radians.toDouble());\ndouble _sin(double x) native "Math_sin";\n');
    addSdkLibrary('mirrors','library dart.mirrors;');
    addSdkLibrary('nativewrappers','library dart.nativewrappers;');
    addSdkLibrary('profiler','library dart.profiler;');
    addSdkLibrary('typed_data','library dart.typed_data;');
    addSdkLibrary('vmservice_io','library dart.vmservice_io;');
    addSdkLibrary('_builtin','library dart._builtin;');
    addSdkLibrary('_internal','library dart._internal;\nclass Symbol {}\nclass ExternalName {\n  final String name;\n  const ExternalName(this.name);\n}\n');
    addSdkLibrary('_vmservice','library dart._vmservice;');
    return dartLibraries;
};
export class properties {
}
